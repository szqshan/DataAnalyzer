<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®åº“åˆ†æç³»ç»Ÿæµ‹è¯•é¡µé¢</title>
</head>
<body>
    <h1>æ•°æ®åº“åˆ†æç³»ç»Ÿ - æ¥å£æµ‹è¯•é¡µé¢</h1>
    
    <!-- ç”¨æˆ·ä¿¡æ¯è®¾ç½® -->
    <div>
        <h2>ç”¨æˆ·ä¿¡æ¯è®¾ç½®</h2>
        <label>ç”¨æˆ·ID: <input type="text" id="userId" value="test_user_001" placeholder="ç”¨æˆ·ID"></label><br><br>
        <label>ç”¨æˆ·å: <input type="text" id="username" value="æµ‹è¯•ç”¨æˆ·" placeholder="ç”¨æˆ·å"></label><br><br>
        <button onclick="setUserInfo()">è®¾ç½®ç”¨æˆ·ä¿¡æ¯</button>
        <div id="currentUser">å½“å‰ç”¨æˆ·: æœªè®¾ç½®</div>
    </div>

    <hr>

    <!-- 1. å¥åº·æ£€æŸ¥ -->
    <div>
        <h2>1. å¥åº·æ£€æŸ¥</h2>
        <button onclick="checkHealth()">æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€</button>
        <pre id="healthResult"></pre>
    </div>

    <hr>

    <!-- 2. ç³»ç»ŸçŠ¶æ€ -->
    <div>
        <h2>2. ç³»ç»ŸçŠ¶æ€</h2>
        <button onclick="getStatus()">è·å–ç³»ç»ŸçŠ¶æ€</button>
        <pre id="statusResult"></pre>
    </div>

    <hr>

    <!-- 3. CSVæ–‡ä»¶ä¸Šä¼  -->
    <div>
        <h2>3. CSVæ–‡ä»¶ä¸Šä¼ </h2>
        <input type="file" id="csvFile" accept=".csv"><br><br>
        <label>è¡¨å: <input type="text" id="tableName" value="data_table" placeholder="è¡¨å"></label><br><br>
        <button onclick="uploadCSV()">ä¸Šä¼ CSVæ–‡ä»¶</button>
        <pre id="uploadResult"></pre>
    </div>

    <hr>

    <!-- 4. æµå¼æ•°æ®åˆ†æ (é‡ç‚¹æµ‹è¯•) -->
    <div>
        <h2>4. æµå¼æ•°æ®åˆ†æ (é‡ç‚¹æµ‹è¯•)</h2>
        <label>åˆ†ææŸ¥è¯¢: 
            <textarea id="analysisQuery" rows="3" cols="80" placeholder="è¾“å…¥ä½ çš„æ•°æ®åˆ†æéœ€æ±‚ï¼Œä¾‹å¦‚ï¼šåˆ†ææ•°æ®çš„åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯å¹¶ç”Ÿæˆè¯¦ç»†çš„HTMLæŠ¥å‘Š">åˆ†ææ•°æ®çš„åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯ï¼ŒåŒ…æ‹¬å„å­—æ®µçš„åˆ†å¸ƒæƒ…å†µï¼Œç”Ÿæˆä¸€ä¸ªè¯¦ç»†çš„HTMLåˆ†ææŠ¥å‘Š</textarea>
        </label><br><br>
        <button onclick="startAnalysis()" id="analyzeBtn">å¼€å§‹æµå¼åˆ†æ</button>
        <button onclick="stopAnalysis()" id="stopBtn" disabled>åœæ­¢åˆ†æ</button><br><br>
        
        <h3>æµå¼å“åº”æ—¥å¿—:</h3>
        <div style="display: flex; gap: 10px;">
            <div style="flex:1; min-width: 0;">
                <strong>çŠ¶æ€(Status)</strong>
                <div id="streamStatusLog" style="border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 5px; font-family: monospace; background: #f5f5f5; font-size: 13px;">ç­‰å¾…åˆ†æå¼€å§‹...</div>
            </div>
            <div style="flex:1; min-width: 0;">
                <strong>AIå›å¤</strong>
                <div id="streamAIResponseLog" style="border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 5px; font-family: monospace; background: #f5f5f5; font-size: 13px;">ç­‰å¾…AIå›å¤...</div>
            </div>
            <div style="flex:1; min-width: 0;">
                <strong>å·¥å…·ç»“æœ</strong>
                <div id="streamToolLog" style="border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 5px; font-family: monospace; background: #f5f5f5; font-size: 13px;">æ— </div>
            </div>
            <div style="flex:1; min-width: 0;">
                <strong>é”™è¯¯/Error</strong>
                <div id="streamErrorLog" style="border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 5px; font-family: monospace; background: #fff0f0; font-size: 13px; color: #b00;">æ— </div>
            </div>
        </div>
        <div style="margin-top:10px;">
            <strong>å…¨éƒ¨åŸå§‹æ—¥å¿—</strong>
            <div id="streamLog" style="border: 1px solid #ccc; height: 200px; overflow-y: auto; padding: 5px; font-family: monospace; background: #f5f5f5; font-size: 12px;"></div>
        </div>
        
        <h3>AIå›å¤å†…å®¹:</h3>
        <div id="aiResponse" style="border: 1px solid #ccc; height: 300px; overflow-y: auto; padding: 10px; background: #fff;">
            ç­‰å¾…AIå›å¤...
        </div>
    </div>

    <hr>

    <!-- 5. è·å–æœ€æ–°HTMLæŠ¥å‘Š -->
    <div>
        <h2>5. è·å–æœ€æ–°HTMLæŠ¥å‘Š</h2>
        <button onclick="getLatestReport()">è·å–æœ€æ–°æŠ¥å‘Š</button>
        <button onclick="viewReportInNewTab()" id="viewReportBtn" disabled>åœ¨æ–°æ ‡ç­¾é¡µæŸ¥çœ‹æŠ¥å‘Š</button><br><br>
        <div id="reportInfo"></div>
        <iframe id="reportFrame" style="width: 100%; height: 400px; border: 1px solid #ccc; display: none;"></iframe>
    </div>

    <!-- æ·»åŠ å¿…è¦çš„åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css">

    <style>
        /* æ‰“å­—æœºæ•ˆæœæ ·å¼ */
        .typing-text {
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background-color: #000;
            margin-left: 2px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            50% { opacity: 0; }
        }
        
        /* Markdown æ ·å¼ */
        .markdown-content {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
        }
        
        .markdown-content pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 16px;
            overflow: auto;
        }
        
        .markdown-content code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.9em;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        
        .markdown-content p {
            margin: 0 0 16px;
        }
        
        .markdown-content ul, .markdown-content ol {
            padding-left: 2em;
            margin: 0 0 16px;
        }
    </style>

    <script>
        // å…¨å±€å˜é‡
        let currentReader = null;
        let currentUserId = 'test_user_001';
        let currentUsername = 'æµ‹è¯•ç”¨æˆ·';
        let latestReportHtml = '';

        // è®¾ç½®ç”¨æˆ·ä¿¡æ¯
        function setUserInfo() {
            currentUserId = document.getElementById('userId').value || 'test_user_001';
            currentUsername = document.getElementById('username').value || 'æµ‹è¯•ç”¨æˆ·';
            document.getElementById('currentUser').textContent = `å½“å‰ç”¨æˆ·: ${currentUsername} (${currentUserId})`;
            log('ç”¨æˆ·ä¿¡æ¯å·²è®¾ç½®: ' + currentUsername);
        }

        // è·å–è¯·æ±‚å¤´
        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'X-User-ID': currentUserId,
                'X-Username': encodeURIComponent(currentUsername)
            };
        }

        // æ—¥å¿—è®°å½•å‡½æ•°
        function log(message) {
            console.log(message);
            const logDiv = document.getElementById('streamLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}<br/>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // åˆ†ç±»æ—¥å¿—è®°å½•å‡½æ•°
        function logByType(type, message) {
            const map = {
                'status': 'streamStatusLog',
                'ai_response': 'streamAIResponseLog',
                'tool_result': 'streamToolLog',
                'error': 'streamErrorLog',
                'html_ready': 'streamStatusLog', // ä¹Ÿå½’ä¸ºçŠ¶æ€
                'default': 'streamLog'
            };
            const divId = map[type] || map['default'];
            const div = document.getElementById(divId);
            const timestamp = new Date().toLocaleTimeString();
            div.innerHTML += `[${timestamp}] ${message}<br/>`;
            div.scrollTop = div.scrollHeight;
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            document.getElementById('streamLog').innerHTML = '';
            document.getElementById('streamStatusLog').innerHTML = '';
            document.getElementById('streamAIResponseLog').innerHTML = '';
            document.getElementById('streamToolLog').innerHTML = '';
            document.getElementById('streamErrorLog').innerHTML = '';
            document.getElementById('aiResponse').innerHTML = '';
        }

        // 1. å¥åº·æ£€æŸ¥
        async function checkHealth() {
            try {
                log('æ­£åœ¨æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€...');
                const response = await fetch('http://localhost:5000/api/health');
                const data = await response.json();
                document.getElementById('healthResult').textContent = JSON.stringify(data, null, 2);
                log('å¥åº·æ£€æŸ¥å®Œæˆ');
            } catch (error) {
                log('å¥åº·æ£€æŸ¥å¤±è´¥: ' + error.message);
                document.getElementById('healthResult').textContent = 'Error: ' + error.message;
            }
        }

        // 2. è·å–ç³»ç»ŸçŠ¶æ€
        async function getStatus() {
            try {
                log('æ­£åœ¨è·å–ç³»ç»ŸçŠ¶æ€...');
                const response = await fetch('http://localhost:5000/api/status', {
                    method: 'GET',
                    headers: getHeaders()
                });
                const data = await response.json();
                document.getElementById('statusResult').textContent = JSON.stringify(data, null, 2);
                log('ç³»ç»ŸçŠ¶æ€è·å–å®Œæˆ');
            } catch (error) {
                log('è·å–ç³»ç»ŸçŠ¶æ€å¤±è´¥: ' + error.message);
                document.getElementById('statusResult').textContent = 'Error: ' + error.message;
            }
        }

        // 3. ä¸Šä¼ CSVæ–‡ä»¶
        async function uploadCSV() {
            const fileInput = document.getElementById('csvFile');
            const tableName = document.getElementById('tableName').value || 'data_table';
            
            if (!fileInput.files.length) {
                alert('è¯·é€‰æ‹©CSVæ–‡ä»¶');
                return;
            }

            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('file', file);
            formData.append('tableName', tableName);
            formData.append('userId', currentUserId);
            formData.append('username', currentUsername);

            try {
                log('æ­£åœ¨ä¸Šä¼ CSVæ–‡ä»¶: ' + file.name);
                
                const response = await fetch('http://localhost:5000/api/upload', {
                    method: 'POST',
                    headers: {
                        'X-User-ID': currentUserId,
                        'X-Username': encodeURIComponent(currentUsername)
                    },
                    body: formData
                });

                const data = await response.json();
                document.getElementById('uploadResult').textContent = JSON.stringify(data, null, 2);
                
                if (data.success) {
                    log(`CSVä¸Šä¼ æˆåŠŸ: ${data.data.rows_imported} è¡Œæ•°æ®å·²å¯¼å…¥`);
                } else {
                    log('CSVä¸Šä¼ å¤±è´¥: ' + data.message);
                }
            } catch (error) {
                log('CSVä¸Šä¼ å‡ºé”™: ' + error.message);
                document.getElementById('uploadResult').textContent = 'Error: ' + error.message;
            }
        }

        // é…ç½® marked
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                }
                return hljs.highlightAuto(code).value;
            },
            breaks: true,
            gfm: true
        });

        // æ‰“å­—æœºæ•ˆæœç±»
        class TypingText {
            constructor(element, options = {}) {
                this.element = element;
                this.options = {
                    speed: options.speed || 30,
                    cursor: options.cursor !== false,
                    onComplete: options.onComplete || (() => {})
                };
                
                this.queue = [];
                this.isTyping = false;
                this.currentText = '';
                
                if (this.options.cursor) {
                    this.cursor = document.createElement('span');
                    this.cursor.className = 'typing-cursor';
                    this.element.appendChild(this.cursor);
                }
            }
            
            type(text) {
                this.queue.push(text);
                if (!this.isTyping) {
                    this.startTyping();
                }
            }
            
            async startTyping() {
                this.isTyping = true;
                
                while (this.queue.length > 0) {
                    const text = this.queue.shift();
                    await this.typeText(text);
                }
                
                this.isTyping = false;
                this.options.onComplete();
            }
            
            async typeText(text) {
                const words = text.split(/(\s+)/);
                
                for (const word of words) {
                    this.currentText += word;
                    this.element.innerHTML = marked.parse(this.currentText);
                    if (this.options.cursor) {
                        this.element.appendChild(this.cursor);
                    }
                    await new Promise(resolve => setTimeout(resolve, this.options.speed));
                }
            }
            
            skip() {
                this.queue = [];
                if (this.isTyping) {
                    this.isTyping = false;
                    this.currentText += this.queue.join('');
                    this.element.innerHTML = marked.parse(this.currentText);
                    if (this.options.cursor) {
                        this.element.appendChild(this.cursor);
                    }
                    this.options.onComplete();
                }
            }
        }

        // 4. å¼€å§‹æµå¼åˆ†æ (ä¿®å¤ç‰ˆæœ¬ - å‚è€ƒå·¥ä½œæ­£å¸¸çš„å‰ç«¯ä»£ç )
        async function startAnalysis() {
            const query = document.getElementById('analysisQuery').value.trim();
            if (!query) {
                alert('è¯·è¾“å…¥åˆ†ææŸ¥è¯¢');
                return;
            }

            // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
            clearLog();
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            log('=== å¼€å§‹æµå¼åˆ†æ ===');
            log('åˆ†ææŸ¥è¯¢: ' + query);

            try {
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„æµå¼è¯·æ±‚æ–¹å¼
                const response = await fetch('http://localhost:5000/api/analyze-stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache',
                        'X-User-ID': currentUserId,
                        'X-Username': encodeURIComponent(currentUsername)
                    },
                    body: JSON.stringify({ 
                        query: query,
                        userId: currentUserId,
                        username: currentUsername
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½¿ç”¨ReadableStreamæ­£ç¡®å¤„ç†æµå¼æ•°æ®
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                currentReader = reader;
                let buffer = '';

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            log('=== æµå¼åˆ†æå®Œæˆ ===');
                            break;
                        }
                        
                        // è§£ç æ•°æ®å—
                        buffer += decoder.decode(value, { stream: true });
                        
                        // æŒ‰è¡Œå¤„ç†æ•°æ®
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€ä¸ªä¸å®Œæ•´çš„è¡Œ
                        
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            
                            if (trimmedLine === '') {
                                continue; // è·³è¿‡ç©ºè¡Œ
                            }
                            
                            // ğŸ”¥ å¤„ç†Server-Sent Eventsæ ¼å¼
                            if (trimmedLine.startsWith('data: ')) {
                                try {
                                    const jsonStr = trimmedLine.slice(6); // ç§»é™¤ 'data: '
                                    
                                    if (jsonStr === '[DONE]') {
                                        log('æ”¶åˆ°å®Œæˆä¿¡å·');
                                        break;
                                    }
                                    
                                    const data = JSON.parse(jsonStr);
                                    handleStreamMessage(data);
                                    
                                } catch (parseError) {
                                    log('è§£ææµæ•°æ®å¤±è´¥: ' + trimmedLine);
                                    console.error('Parse error:', parseError);
                                }
                            }
                        }
                    }
                } finally {
                    if (currentReader) {
                        currentReader.releaseLock();
                        currentReader = null;
                    }
                }

            } catch (error) {
                log('æµå¼åˆ†æå‡ºé”™: ' + error.message);
                console.error('Stream error:', error);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }

        // ä¿®æ”¹å¤„ç†æµå¼æ¶ˆæ¯çš„å‡½æ•°
        function handleStreamMessage(data) {
            const type = data.type;
            
            switch (type) {
                case 'status':
                    logByType('status', data.message);
                    log(`[çŠ¶æ€] ${data.message}`);
                    break;
                    
                case 'ai_response':
                    const aiDiv = document.getElementById('aiResponse');
                    if (!aiDiv.typingText) {
                        aiDiv.typingText = new TypingText(aiDiv, {
                            speed: 20,
                            cursor: true,
                            onComplete: () => {
                                aiDiv.scrollTop = aiDiv.scrollHeight;
                            }
                        });
                    }
                    aiDiv.typingText.type(data.content);
                    logByType('ai_response', data.content);
                    log(`[AIå›å¤] æ”¶åˆ° ${data.content.length} å­—ç¬¦`);
                    break;
                    
                case 'tool_result':
                    logByType('tool_result', `${data.tool}: ${JSON.stringify(data.result).substring(0, 200)}...`);
                    log(`[å·¥å…·ç»“æœ] ${data.tool}: ${JSON.stringify(data.result).substring(0, 200)}...`);
                    break;
                    
                case 'html_ready':
                    logByType('status', `[HTMLå°±ç»ª] æŠ¥å‘Šæ–‡ä»¶: ${data.file_path}`);
                    log(`[HTMLå°±ç»ª] æŠ¥å‘Šæ–‡ä»¶: ${data.file_path}`);
                    setTimeout(() => {
                        getLatestReport();
                    }, 1000);
                    break;
                    
                case 'error':
                    logByType('error', data.message);
                    log(`[é”™è¯¯] ${data.message}`);
                    break;
                    
                default:
                    logByType('default', JSON.stringify(data));
                    log(`[æœªçŸ¥æ¶ˆæ¯] ${JSON.stringify(data)}`);
            }
        }

        // åœæ­¢åˆ†æ
        function stopAnalysis() {
            if (currentReader) {
                currentReader.cancel();
                currentReader = null;
            }
            log('åˆ†æå·²åœæ­¢');
            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // 5. è·å–æœ€æ–°HTMLæŠ¥å‘Š (ä¿®å¤ç‰ˆæœ¬)
        async function getLatestReport() {
            try {
                log('æ­£åœ¨è·å–æœ€æ–°HTMLæŠ¥å‘Š...');
                
                const response = await fetch('http://localhost:5000/api/latest-report', {
                    method: 'GET',
                    headers: getHeaders()
                });

                const data = await response.json();
                
                if (data.success && data.html_content) {
                    log('HTMLæŠ¥å‘Šè·å–æˆåŠŸ');
                    latestReportHtml = data.html_content;
                    
                    // æ˜¾ç¤ºæŠ¥å‘Šä¿¡æ¯
                    document.getElementById('reportInfo').innerHTML = `
                        <strong>æŠ¥å‘Šä¿¡æ¯:</strong><br>
                        æ–‡ä»¶è·¯å¾„: ${data.file_path}<br>
                        æœ€åä¿®æ”¹: ${data.last_modified}<br>
                        æ–‡ä»¶å¤§å°: ${data.file_size} å­—ç¬¦<br>
                        <button onclick="showReportInFrame()">åœ¨ä¸‹æ–¹é¢„è§ˆ</button>
                    `;
                    
                    // å¯ç”¨æŸ¥çœ‹æŒ‰é’®
                    document.getElementById('viewReportBtn').disabled = false;
                    
                    log(`HTMLæŠ¥å‘ŠåŠ è½½æˆåŠŸï¼Œå¤§å°: ${data.file_size} å­—ç¬¦`);
                } else {
                    log('è·å–HTMLæŠ¥å‘Šå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                    document.getElementById('reportInfo').innerHTML = 'è·å–æŠ¥å‘Šå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯');
                }
            } catch (error) {
                log('è·å–HTMLæŠ¥å‘Šå‡ºé”™: ' + error.message);
                document.getElementById('reportInfo').innerHTML = 'Error: ' + error.message;
            }
        }

        // åœ¨iframeä¸­æ˜¾ç¤ºæŠ¥å‘Š
        function showReportInFrame() {
            if (latestReportHtml) {
                const iframe = document.getElementById('reportFrame');
                iframe.style.display = 'block';
                iframe.srcdoc = latestReportHtml;
                log('HTMLæŠ¥å‘Šå·²åœ¨ä¸‹æ–¹æ˜¾ç¤º');
            }
        }

        // åœ¨æ–°æ ‡ç­¾é¡µæŸ¥çœ‹æŠ¥å‘Š
        function viewReportInNewTab() {
            if (latestReportHtml) {
                const newWindow = window.open();
                newWindow.document.write(latestReportHtml);
                newWindow.document.close();
                log('HTMLæŠ¥å‘Šå·²åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®é»˜è®¤ç”¨æˆ·ä¿¡æ¯
        window.addEventListener('load', function() {
            setUserInfo();
            log('æµ‹è¯•é¡µé¢å·²åŠ è½½å®Œæˆ');
            
            // è‡ªåŠ¨è¿›è¡Œè¿æ¥æµ‹è¯•
            setTimeout(() => {
                checkHealth();
            }, 500);
        });

        // ğŸ”¥ æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('unhandledrejection', event => {
            console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
            log('å…¨å±€é”™è¯¯: ' + event.reason);
        });

        window.addEventListener('error', event => {
            console.error('å…¨å±€é”™è¯¯:', event.error);
            log('JavaScripté”™è¯¯: ' + event.error);
        });
    </script>
</body>
</html>